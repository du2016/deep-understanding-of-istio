secretcontroller


# 初始化SDS Server

```
func (s *Server) initSDSServer(args *PilotArgs) {
	if s.kubeClient != nil {
		if !features.EnableXDSIdentityCheck {
			// Make sure we have security
			log.Warnf("skipping Kubernetes credential reader; PILOT_ENABLE_XDS_IDENTITY_CHECK must be set to true for this feature.")
		} else {
			// TODO move this to a startup function and pass stop
			sc := kubesecrets.NewMulticluster(s.kubeClient, s.clusterID, args.RegistryOptions.ClusterRegistriesNamespace, make(chan struct{}))
			sc.AddEventHandler(func(name, namespace string) {
				s.XDSServer.ConfigUpdate(&model.PushRequest{
					Full: false,
					ConfigsUpdated: map[model.ConfigKey]struct{}{
						{
							Kind:      gvk.Secret,
							Name:      name,
							Namespace: namespace,
						}: {},
					},
					Reason: []model.TriggerReason{model.SecretTrigger},
				})
			})
			s.XDSServer.Generators[v3.SecretType] = xds.NewSecretGen(sc, s.XDSServer.Cache)
		}
	}
}
```


# NewMulticluster

func NewMulticluster(client kube.Client, localCluster, secretNamespace string, stop chan struct{}) *Multicluster {
	m := &Multicluster{
		remoteKubeControllers: map[string]*SecretsController{},
		localCluster:          localCluster,
		stop:                  stop,
	}
	// Add the local cluster
	m.addMemberCluster(client, localCluster)
	sc := secretcontroller.StartSecretController(client,
		func(c kube.Client, k string) error { m.addMemberCluster(c, k); return nil },
		func(c kube.Client, k string) error { m.updateMemberCluster(c, k); return nil },
		func(k string) error { m.deleteMemberCluster(k); return nil },
		secretNamespace,
		time.Millisecond*100,
		stop)
	m.secretController = sc
	return m
}


# start secret controller

func StartSecretController(
	k8s kubernetes.Interface,
	addCallback addSecretCallback, updateCallback updateSecretCallback,
	removeCallback removeSecretCallback,
	namespace string,
	syncInterval time.Duration,
	stop <-chan struct{},
) *Controller {
	clusterStore := newClustersStore()
	controller := NewController(k8s, namespace, clusterStore, addCallback, updateCallback, removeCallback)
	controller.syncInterval = syncInterval

	go controller.Run(stop)

	return controller
}

# call backs

## addMemberCluster

func (m *Multicluster) addMemberCluster(clients kube.Client, key string) {
	log.Infof("initializing Kubernetes credential reader for cluster %v", key)
	sc := NewSecretsController(clients, key)
	m.m.Lock()
	m.remoteKubeControllers[key] = sc
	m.m.Unlock()
	clients.RunAndWait(m.stop)
}

## updateMemberCluster

func (m *Multicluster) updateMemberCluster(clients kube.Client, key string) {
	m.deleteMemberCluster(key)
	m.addMemberCluster(clients, key)
}

## deleteMemberCluster


func (m *Multicluster) deleteMemberCluster(key string) {
	m.m.Lock()
	delete(m.remoteKubeControllers, key)
	m.m.Unlock()
}


# NewSecretsController

func NewSecretsController(client kube.Client, clusterID string) *SecretsController {
	// Informer is lazy loaded, load it now
	_ = client.KubeInformer().Core().V1().Secrets().Informer()

	return &SecretsController{
		secrets: client.KubeInformer().Core().V1().Secrets(),

		sar:                client.AuthorizationV1().SubjectAccessReviews(),
		clusterID:          clusterID,
		authorizationCache: make(map[authorizationKey]authorizationResponse),
	}
}


# Secret Generate

```go
func (s *SecretGen) Generate(proxy *model.Proxy, _ *model.PushContext, w *model.WatchedResource, req *model.PushRequest) model.Resources {
	...
    // 查找所需的secret controller
	secrets, err := s.secrets.ForCluster(proxy.Metadata.ClusterID)
	if err != nil {
		adsLog.Warnf("proxy %v is from an unknown cluster, cannot retrieve certificates: %v", proxy.ID, err)
		return nil
	}
    // 判断客户端身份
	if err := secrets.Authorize(proxy.VerifiedIdentity.ServiceAccount, proxy.VerifiedIdentity.Namespace); err != nil {
		adsLog.Warnf("proxy %v is not authorized to receive secrets: %v", proxy.ID, err)
		return nil
	}
	if req == nil || !needsUpdate(proxy, req.ConfigsUpdated) {
		return nil
	}
	var updatedSecrets map[model.ConfigKey]struct{}
	if !req.Full {
		updatedSecrets = model.ConfigsOfKind(req.ConfigsUpdated, gvk.Secret)
	}
	results := model.Resources{}
	for _, resource := range w.ResourceNames {
        // 获取所需的secret resource
		sr, err := parseResourceName(resource, proxy.ConfigNamespace)
		if err != nil {
			adsLog.Warnf("error parsing resource name: %v", err)
			continue
		}

		if updatedSecrets != nil {
			if !containsAny(updatedSecrets, relatedConfigs(model.ConfigKey{Kind: gvk.Secret, Name: sr.Name, Namespace: sr.Namespace})) {
				// This is an incremental update, filter out secrets that are not updated.
				continue
			}
		}
        // 请求的secret和请求的secret必须在同一命名空间
		if err := s.proxyAuthorizedForSecret(proxy, sr); err != nil {
			adsLog.Warnf("requested secret %v not accessible for proxy %v: %v", sr.ResourceName, proxy.ID, err)
			continue
		}
        // 从cache获取，根据PILOT_XDS_CACHE_SIZE默认20000和PILOT_ENABLE_XDS_CACHE默认开启控制
		if cached, f := s.cache.Get(sr); f {
			// If it is in the Cache, add it and continue
			results = append(results, cached)
			continue
		}

		isCAOnlySecret := strings.HasSuffix(sr.Name, GatewaySdsCaSuffix)
		if isCAOnlySecret {
			secret := secrets.GetCaCert(sr.Name, sr.Namespace)
			if secret != nil {
				res := toEnvoyCaSecret(sr.ResourceName, secret)
				results = append(results, res)
				s.cache.Add(sr, res)
			} else {
				adsLog.Warnf("failed to fetch ca certificate for %v", sr.ResourceName)
			}
		} else {
			key, cert := secrets.GetKeyAndCert(sr.Name, sr.Namespace)
			if key != nil && cert != nil {
				res := toEnvoyKeyCertSecret(sr.ResourceName, key, cert)
				results = append(results, res)
				s.cache.Add(sr, res)
			} else {
				adsLog.Warnf("failed to fetch key and certificate for %v", sr.ResourceName)
			}
		}
	}
	return results
}
```